ncverilog(64): 15.20-s051: (c) Copyright 1995-2018 Cadence Design Systems, Inc.
TOOL:	ncverilog	15.20-s051: Started on Mar 01, 2023 at 02:15:20 IST
ncverilog
	topMod.v
	test03.v
	cla.v
	multi_f.v
	-hal
Recompiling... reason: file './topMod.v' is newer than expected.
	expected: Tue Feb 28 21:59:35 2023
	actual:   Wed Mar  1 02:14:37 2023
file: topMod.v
	module worklib.booth32x32_top:v
		errors: 0, warnings: 0
		Caching library 'worklib' ....... Done
	Elaborating the design hierarchy:
	Building instance overlay tables: .................... Done
	Generating native compiled code:
		worklib.booth32x32_top:v <0x1f4d4d3d>
			streams:   4, words:   637
	Building instance specific data structures.
	Loading native compiled code:     .................... Done
	Design hierarchy summary:
		                  Instances  Unique
		Modules:                 12       6
		Registers:                6       6
		Scalar wires:          2507       -
		Vectored wires:          48       -
		Always blocks:            2       2
		Cont. assignments:     2526      43
		Pseudo assignments:       2       2
		Simulation timescale:   1ps
	Writing initial simulation snapshot: worklib.booth32x32_top:v
hal(64): 15.20-s051: (c) Copyright 1995-2018 Cadence Design Systems, Inc.
hal: Options:   -cdslib ./INCA_libs/irun.lnx8664.15.20.nc/cds.lib -logfile ncverilog.log -f /home/sgeuser114/Desktop/venkat/singleCycleProcessor/topLevel/rtl/INCA_libs/irun.lnx8664.15.20.nc/hal.args .
hal: Snapshot:  worklib.booth32x32_top:v.
hal: Workspace: /home/sgeuser114/Desktop/venkat/singleCycleProcessor/topLevel/rtl.
hal: Date: Wed Mar 01 02:15:21 IST 2023.

hal: Running on elaborated SNAPSHOT.....

  ==========================================================================
Performing lint checks 

halcheck(64): 15.20-s051: (c) Copyright 1995-2018 Cadence Design Systems, Inc.
visadev(64): 15.20-s051: (c) Copyright 1995-2018 Cadence Design Systems, Inc.
`timescale 1ns/1ps
|
halcheck: *N,CDNOTE (./topMod.v,1|0): The compiler directive '`timescale' is used in the RTL.
module booth32x32_top (
|
halcheck: *W,DIFFMN (./topMod.v,3|0): Module name 'booth32x32_top' differs from file name 'topMod.v'.
module booth32x32_top (
|
halcheck: *N,PRTCNT (./topMod.v,3|0): Module/Entity 'booth32x32_top' contains '5' ports.
halcheck: (./topMod.v,3): Number of Input ports: 3.
halcheck: (./topMod.v,3): Number of Output ports: 2.
        .Cin(1'b0),
|
halcheck: *W,IPRTEX (./topMod.v,55|0): A constant is used in a port expression.
    input  wire [31:0] A,
|
halcheck: *W,STYVAL (./topMod.v,4|0): Numeric value '31' used for identifier 'A'. Use constants to avoid portability issues.
    input  wire [31:0] B,
|
halcheck: *W,STYVAL (./topMod.v,5|0): Numeric value '31' used for identifier 'B'. Use constants to avoid portability issues.
    output wire [31:0] PROD_MSB,     // upper 32 bits
|
halcheck: *W,STYVAL (./topMod.v,7|0): Numeric value '31' used for identifier 'PROD_MSB'. Use constants to avoid portability issues.
    output wire [31:0] PROD_LSB      // lower 32 bits
|
halcheck: *W,STYVAL (./topMod.v,8|0): Numeric value '31' used for identifier 'PROD_LSB'. Use constants to avoid portability issues.
    input  wire [31:0] A,
|
halcheck: *W,LCVARN (./topMod.v,4|0): Net name 'A' uses uppercase characters.
    input  wire [31:0] B,
|
halcheck: *W,LCVARN (./topMod.v,5|0): Net name 'B' uses uppercase characters.
    output wire [31:0] PROD_MSB,     // upper 32 bits
|
halcheck: *W,LCVARN (./topMod.v,7|0): Net name 'PROD_MSB' uses uppercase characters.
    output wire [31:0] PROD_LSB      // lower 32 bits
|
halcheck: *W,LCVARN (./topMod.v,8|0): Net name 'PROD_LSB' uses uppercase characters.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,LCVARN (./topMod.v,14|0): Net name 'PP0' uses uppercase characters.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,NUMSUF (./topMod.v,14|0): Identifier 'PP0' has a numeric value suffix.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,STYVAL (./topMod.v,14|0): Numeric value '63' used for identifier 'PP0'. Use constants to avoid portability issues.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,LCVARN (./topMod.v,14|0): Net name 'PP1' uses uppercase characters.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,NUMSUF (./topMod.v,14|0): Identifier 'PP1' has a numeric value suffix.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,LCVARN (./topMod.v,14|0): Net name 'PP2' uses uppercase characters.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,NUMSUF (./topMod.v,14|0): Identifier 'PP2' has a numeric value suffix.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,LCVARN (./topMod.v,14|0): Net name 'PP3' uses uppercase characters.
    wire [63:0] PP0, PP1, PP2, PP3;
|
halcheck: *W,NUMSUF (./topMod.v,14|0): Identifier 'PP3' has a numeric value suffix.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,LCVARN (./topMod.v,15|0): Net name 'PP4' uses uppercase characters.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,NUMSUF (./topMod.v,15|0): Identifier 'PP4' has a numeric value suffix.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,STYVAL (./topMod.v,15|0): Numeric value '63' used for identifier 'PP4'. Use constants to avoid portability issues.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,LCVARN (./topMod.v,15|0): Net name 'PP5' uses uppercase characters.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,NUMSUF (./topMod.v,15|0): Identifier 'PP5' has a numeric value suffix.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,LCVARN (./topMod.v,15|0): Net name 'PP6' uses uppercase characters.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,NUMSUF (./topMod.v,15|0): Identifier 'PP6' has a numeric value suffix.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,LCVARN (./topMod.v,15|0): Net name 'PP7' uses uppercase characters.
    wire [63:0] PP4, PP5, PP6, PP7;
|
halcheck: *W,NUMSUF (./topMod.v,15|0): Identifier 'PP7' has a numeric value suffix.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,LCVARN (./topMod.v,16|0): Net name 'PP8' uses uppercase characters.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,NUMSUF (./topMod.v,16|0): Identifier 'PP8' has a numeric value suffix.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,STYVAL (./topMod.v,16|0): Numeric value '63' used for identifier 'PP8'. Use constants to avoid portability issues.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,LCVARN (./topMod.v,16|0): Net name 'PP9' uses uppercase characters.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,NUMSUF (./topMod.v,16|0): Identifier 'PP9' has a numeric value suffix.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,LCVARN (./topMod.v,16|0): Net name 'PP10' uses uppercase characters.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,NUMSUF (./topMod.v,16|0): Identifier 'PP10' has a numeric value suffix.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,LCVARN (./topMod.v,16|0): Net name 'PP11' uses uppercase characters.
    wire [63:0] PP8, PP9, PP10, PP11;
|
halcheck: *W,NUMSUF (./topMod.v,16|0): Identifier 'PP11' has a numeric value suffix.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,LCVARN (./topMod.v,17|0): Net name 'PP12' uses uppercase characters.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,NUMSUF (./topMod.v,17|0): Identifier 'PP12' has a numeric value suffix.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,STYVAL (./topMod.v,17|0): Numeric value '63' used for identifier 'PP12'. Use constants to avoid portability issues.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,LCVARN (./topMod.v,17|0): Net name 'PP13' uses uppercase characters.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,NUMSUF (./topMod.v,17|0): Identifier 'PP13' has a numeric value suffix.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,LCVARN (./topMod.v,17|0): Net name 'PP14' uses uppercase characters.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,NUMSUF (./topMod.v,17|0): Identifier 'PP14' has a numeric value suffix.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,LCVARN (./topMod.v,17|0): Net name 'PP15' uses uppercase characters.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,NUMSUF (./topMod.v,17|0): Identifier 'PP15' has a numeric value suffix.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,LCVARN (./topMod.v,17|0): Net name 'PP16' uses uppercase characters.
    wire [63:0] PP12, PP13, PP14, PP15, PP16;
|
halcheck: *W,NUMSUF (./topMod.v,17|0): Identifier 'PP16' has a numeric value suffix.
    wire [63:0] s_um, c_arry;
|
halcheck: *W,STYVAL (./topMod.v,33|0): Numeric value '63' used for identifier 's_um'. Use constants to avoid portability issues.
    wire [63:0] FINAL_PROD;
|
halcheck: *W,LCVARN (./topMod.v,47|0): Net name 'FINAL_PROD' uses uppercase characters.
    wire [63:0] FINAL_PROD;
|
halcheck: *W,STYVAL (./topMod.v,47|0): Numeric value '63' used for identifier 'FINAL_PROD'. Use constants to avoid portability issues.
    wire        Cout;
|
halcheck: *W,LCVARN (./topMod.v,48|0): Net name 'Cout' uses uppercase characters.
    wire [63:0] cry_sh;
|
halcheck: *W,STYVAL (./topMod.v,49|0): Numeric value '63' used for identifier 'cry_sh'. Use constants to avoid portability issues.
    assign cry_sh = (c_arry << 1);
|
halcheck: *W,SHFTOF (./topMod.v,50|0): Shift overflow in module/design-unit booth32x32_top, some bits will be lost.
    module booth_radix4_multiplier (
|
halcheck: *N,IDLENG (./multi_f.v,3|0): Identifier name 'booth_radix4_multiplier' is not of appropriate length (4 to 16 characters).
`timescale 1ns/1ps
|
halcheck: *N,CDNOTE (./multi_f.v,1|0): The compiler directive '`timescale' is used in the RTL.
	s = 2'b11;
|
halcheck: *W,CTLCHR (./multi_f.v,18|0): HDL source line contains one or more control characters.
    	us = 2'b00;
|
halcheck: *W,CTLCHR (./multi_f.v,19|0): HDL source line contains one or more control characters.
    	ne_1 = 1'b0;
|
halcheck: *W,CTLCHR (./multi_f.v,20|0): HDL source line contains one or more control characters.
                3'b000, 3'b111: partial[i] = 64'b0;                     // 0 × A
|
halcheck: *W,BITUNS (./multi_f.v,36|0): Not all bits of constant '64'b0' are explicitly specified.
halcheck: (./multi_f.v,36): Constant extended by 63 bits to -> 64'b(000000000000000000000000000000000000000000000000000000000000000)0.
                3'b001, 3'b010: partial[i] = {{32{A[31]}}, A} << (2*i); // +1 × A
|
halcheck: *W,MAXLEN (./multi_f.v,37|0): The HDL source line is 81 characters, which exceeds the recommended length of 80 characters.
                3'b011:         partial[i] = {{32{A[31]}}, A} << (2*i+1); // +2 × A
|
halcheck: *W,MAXLEN (./multi_f.v,38|0): The HDL source line is 83 characters, which exceeds the recommended length of 80 characters.
                3'b100:         partial[i] = -({{32{A[31]}}, A} << (2*i+1)); // -2 × A
|
halcheck: *W,MAXLEN (./multi_f.v,39|0): The HDL source line is 86 characters, which exceeds the recommended length of 80 characters.
                3'b101, 3'b110: partial[i] = -({{32{A[31]}}, A} << (2*i));   // -1 × A
|
halcheck: *W,MAXLEN (./multi_f.v,40|0): The HDL source line is 86 characters, which exceeds the recommended length of 80 characters.
                default:        partial[i] = 64'b0;
|
halcheck: *W,BITUNS (./multi_f.v,41|0): Not all bits of constant '64'b0' are explicitly specified.
halcheck: (./multi_f.v,41): Constant extended by 63 bits to -> 64'b(000000000000000000000000000000000000000000000000000000000000000)0.
    module booth_radix4_multiplier (
|
halcheck: *W,DIFFMN (./multi_f.v,3|0): Module name 'booth_radix4_multiplier' differs from file name 'multi_f.v'.
    module booth_radix4_multiplier (
|
halcheck: *N,PRTCNT (./multi_f.v,3|0): Module/Entity 'booth_radix4_multiplier' contains '20' ports.
halcheck: (./multi_f.v,3): Number of Input ports: 3.
halcheck: (./multi_f.v,3): Number of Output ports: 17.
    input  [31:0] A,     // Multiplicand
|
halcheck: *W,STYVAL (./multi_f.v,4|0): Numeric value '31' used for identifier 'A'. Use constants to avoid portability issues.
    input  [31:0] B,     // Multiplier
|
halcheck: *W,STYVAL (./multi_f.v,5|0): Numeric value '31' used for identifier 'B'. Use constants to avoid portability issues.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,NUMSUF (./multi_f.v,7|0): Identifier 'PP0' has a numeric value suffix.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,STYVAL (./multi_f.v,7|0): Numeric value '63' used for identifier 'PP0'. Use constants to avoid portability issues.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,NUMSUF (./multi_f.v,7|0): Identifier 'PP1' has a numeric value suffix.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *N,DECLIN (./multi_f.v,7|0): Use a separate line for each HDL declaration.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,NUMSUF (./multi_f.v,7|0): Identifier 'PP2' has a numeric value suffix.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,NUMSUF (./multi_f.v,7|0): Identifier 'PP3' has a numeric value suffix.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,NUMSUF (./multi_f.v,8|0): Identifier 'PP4' has a numeric value suffix.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,STYVAL (./multi_f.v,8|0): Numeric value '63' used for identifier 'PP4'. Use constants to avoid portability issues.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,NUMSUF (./multi_f.v,8|0): Identifier 'PP5' has a numeric value suffix.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *N,DECLIN (./multi_f.v,8|0): Use a separate line for each HDL declaration.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,NUMSUF (./multi_f.v,8|0): Identifier 'PP6' has a numeric value suffix.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,NUMSUF (./multi_f.v,8|0): Identifier 'PP7' has a numeric value suffix.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,NUMSUF (./multi_f.v,9|0): Identifier 'PP8' has a numeric value suffix.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,STYVAL (./multi_f.v,9|0): Numeric value '63' used for identifier 'PP8'. Use constants to avoid portability issues.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,NUMSUF (./multi_f.v,9|0): Identifier 'PP9' has a numeric value suffix.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *N,DECLIN (./multi_f.v,9|0): Use a separate line for each HDL declaration.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,NUMSUF (./multi_f.v,9|0): Identifier 'PP10' has a numeric value suffix.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,NUMSUF (./multi_f.v,9|0): Identifier 'PP11' has a numeric value suffix.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,NUMSUF (./multi_f.v,10|0): Identifier 'PP12' has a numeric value suffix.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,STYVAL (./multi_f.v,10|0): Numeric value '63' used for identifier 'PP12'. Use constants to avoid portability issues.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,NUMSUF (./multi_f.v,10|0): Identifier 'PP13' has a numeric value suffix.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *N,DECLIN (./multi_f.v,10|0): Use a separate line for each HDL declaration.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,NUMSUF (./multi_f.v,10|0): Identifier 'PP14' has a numeric value suffix.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,NUMSUF (./multi_f.v,10|0): Identifier 'PP15' has a numeric value suffix.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,NUMSUF (./multi_f.v,10|0): Identifier 'PP16' has a numeric value suffix.
    input  [31:0] A,     // Multiplicand
|
halcheck: *W,LCVARN (./multi_f.v,4|0): Net name 'A' uses uppercase characters.
    input  [31:0] B,     // Multiplier
|
halcheck: *W,LCVARN (./multi_f.v,5|0): Net name 'B' uses uppercase characters.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,LCVARN (./multi_f.v,7|0): Net name 'PP0' uses uppercase characters.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,LCVARN (./multi_f.v,7|0): Net name 'PP1' uses uppercase characters.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,LCVARN (./multi_f.v,7|0): Net name 'PP2' uses uppercase characters.
    output [63:0] PP0, PP1, PP2, PP3,
|
halcheck: *W,LCVARN (./multi_f.v,7|0): Net name 'PP3' uses uppercase characters.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,LCVARN (./multi_f.v,8|0): Net name 'PP4' uses uppercase characters.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,LCVARN (./multi_f.v,8|0): Net name 'PP5' uses uppercase characters.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,LCVARN (./multi_f.v,8|0): Net name 'PP6' uses uppercase characters.
    output [63:0] PP4, PP5, PP6, PP7,
|
halcheck: *W,LCVARN (./multi_f.v,8|0): Net name 'PP7' uses uppercase characters.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,LCVARN (./multi_f.v,9|0): Net name 'PP8' uses uppercase characters.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,LCVARN (./multi_f.v,9|0): Net name 'PP9' uses uppercase characters.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,LCVARN (./multi_f.v,9|0): Net name 'PP10' uses uppercase characters.
    output [63:0] PP8, PP9, PP10, PP11,
|
halcheck: *W,LCVARN (./multi_f.v,9|0): Net name 'PP11' uses uppercase characters.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,LCVARN (./multi_f.v,10|0): Net name 'PP12' uses uppercase characters.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,LCVARN (./multi_f.v,10|0): Net name 'PP13' uses uppercase characters.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,LCVARN (./multi_f.v,10|0): Net name 'PP14' uses uppercase characters.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,LCVARN (./multi_f.v,10|0): Net name 'PP15' uses uppercase characters.
    output [63:0] PP12, PP13, PP14, PP15, PP16
|
halcheck: *W,LCVARN (./multi_f.v,10|0): Net name 'PP16' uses uppercase characters.
    reg [34:0] B_ext;
|
halcheck: *W,LCVARN (./multi_f.v,14|0): Register name 'B_ext' uses uppercase characters.
    reg [34:0] B_ext;
|
halcheck: *W,STYVAL (./multi_f.v,14|0): Numeric value '34' used for identifier 'B_ext'. Use constants to avoid portability issues.
    reg  [63:0] partial [16:0];
|
halcheck: *W,STYVAL (./multi_f.v,30|0): Numeric value '63' used for identifier 'partial'. Use constants to avoid portability issues.
    always @(*) begin
|
halcheck: *W,NOBLKN (./multi_f.v,17|0): Each block should be labeled with a meaningful name.
    always @(*) begin
|
halcheck: *W,NOBLKN (./multi_f.v,33|0): Each block should be labeled with a meaningful name.
            case (B_ext[2*i +: 3]) // Take 3-bit group
|
halcheck: *W,CDEFCV (./multi_f.v,35|0): The case items of the case statement in module/design-unit booth_enc cover all the numerical values of the case expression. The default clause is not required.
                3'b001, 3'b010: partial[i] = {{32{A[31]}}, A} << (2*i); // +1 × A
|
halcheck: *W,MXUANS (./multi_f.v,37|0): Expression '{{32{A[31]}},A} ...' in module/design-unit booth_enc has both signed and unsigned variables/constants.
halcheck: (./multi_f.v,37): Variable 'i' is signed.
halcheck: (./multi_f.v,37): Variable 'A' is unsigned.
halcheck: (./multi_f.v,37): Variable 'A[31]' is unsigned.
                3'b011:         partial[i] = {{32{A[31]}}, A} << (2*i+1); // +2 × A
|
halcheck: *W,MXUANS (./multi_f.v,38|0): Expression '{{32{A[31]}},A} ...' in module/design-unit booth_enc has both signed and unsigned variables/constants.
halcheck: (./multi_f.v,38): Variable 'i' is signed.
halcheck: (./multi_f.v,38): Variable 'A' is unsigned.
halcheck: (./multi_f.v,38): Variable 'A[31]' is unsigned.
                3'b100:         partial[i] = -({{32{A[31]}}, A} << (2*i+1)); // -2 × A
|
halcheck: *W,SGNUSG (./multi_f.v,39|0): Negative value '-({{32{A[31]}},A} << ((2 * i) + 1))' assigned to an unsigned variable 'partial[i]' in module/design-unit booth_enc.
                3'b100:         partial[i] = -({{32{A[31]}}, A} << (2*i+1)); // -2 × A
|
halcheck: *W,MXUANS (./multi_f.v,39|0): Expression '-({{32{A[31]}},A...' in module/design-unit booth_enc has both signed and unsigned variables/constants.
halcheck: (./multi_f.v,39): Variable 'i' is signed.
halcheck: (./multi_f.v,39): Variable 'A' is unsigned.
halcheck: (./multi_f.v,39): Variable 'A[31]' is unsigned.
                3'b101, 3'b110: partial[i] = -({{32{A[31]}}, A} << (2*i));   // -1 × A
|
halcheck: *W,SGNUSG (./multi_f.v,40|0): Negative value '-({{32{A[31]}},A} << (2 * i))' assigned to an unsigned variable 'partial[i]' in module/design-unit booth_enc.
                3'b101, 3'b110: partial[i] = -({{32{A[31]}}, A} << (2*i));   // -1 × A
|
halcheck: *W,MXUANS (./multi_f.v,40|0): Expression '-({{32{A[31]}},A...' in module/design-unit booth_enc has both signed and unsigned variables/constants.
halcheck: (./multi_f.v,40): Variable 'i' is signed.
halcheck: (./multi_f.v,40): Variable 'A' is unsigned.
halcheck: (./multi_f.v,40): Variable 'A[31]' is unsigned.
`timescale 1ns/1ps
|
halcheck: *N,CDNOTE (./test03.v,1|0): The compiler directive '`timescale' is used in the RTL.
	if (i == 0) begin
|
halcheck: *W,CTLCHR (./test03.v,25|0): HDL source line contains one or more control characters.
      		assign cin_i = cin_chain;
|
halcheck: *W,CTLCHR (./test03.v,26|0): HDL source line contains one or more control characters.
	 end
|
halcheck: *W,CTLCHR (./test03.v,27|0): HDL source line contains one or more control characters.
    	else begin
|
halcheck: *W,CTLCHR (./test03.v,28|0): HDL source line contains one or more control characters.
      		assign cin_i = cout[i-1];
|
halcheck: *W,CTLCHR (./test03.v,29|0): HDL source line contains one or more control characters.
	 end
|
halcheck: *W,CTLCHR (./test03.v,30|0): HDL source line contains one or more control characters.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halcheck: *W,MAXLEN (./test03.v,38|0): The HDL source line is 81 characters, which exceeds the recommended length of 80 characters.
            // cout is the bit-(i+2) contribution that chains to cin of next bit.
|
halcheck: *W,MAXLEN (./test03.v,43|0): The HDL source line is 81 characters, which exceeds the recommended length of 80 characters.
    output wire [63:0] c_arr_y//, c0, c1, c2, c3, c4, c5, s0, s1, s2, s3, s4, s5    // final carry row (interpret as <<1)
|
halcheck: *W,MAXLEN (./test03.v,93|0): The HDL source line is 121 characters, which exceeds the recommended length of 80 characters.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,MAXLEN (./test03.v,95|0): The HDL source line is 81 characters, which exceeds the recommended length of 80 characters.
	assign s_u_m = s6;
|
halcheck: *W,CTLCHR (./test03.v,163|0): HDL source line contains one or more control characters.
	assign c_arr_y = c6;
|
halcheck: *W,CTLCHR (./test03.v,164|0): HDL source line contains one or more control characters.
module pp_tree16x64 (
|
halcheck: *W,DIFFMN (./test03.v,82|0): Module name 'pp_tree16x64' differs from file name 'test03.v'.
module pp_tree16x64 (
|
halcheck: *N,PRTCNT (./test03.v,82|0): Module/Entity 'pp_tree16x64' contains '19' ports.
halcheck: (./test03.v,82): Number of Input ports: 17.
halcheck: (./test03.v,82): Number of Output ports: 2.
        .cin_chain(1'b0),
|
halcheck: *W,IPRTEX (./test03.v,104|0): A constant is used in a port expression.
        .cin_chain(1'b0),
|
halcheck: *W,IPRTEX (./test03.v,109|0): A constant is used in a port expression.
        .cin_chain(1'b0),
|
halcheck: *W,IPRTEX (./test03.v,114|0): A constant is used in a port expression.
        .cin_chain(1'b0),
|
halcheck: *W,IPRTEX (./test03.v,119|0): A constant is used in a port expression.
        .cin_chain(1'b0),
|
halcheck: *W,IPRTEX (./test03.v,139|0): A constant is used in a port expression.
        .cin_chain(1'b0),
|
halcheck: *W,IPRTEX (./test03.v,148|0): A constant is used in a port expression.
        .cin_chain(1'b0),
|
halcheck: *W,IPRTEX (./test03.v,159|0): A constant is used in a port expression.
    input  wire [63:0] P0,  input wire [63:0] P1,
|
halcheck: *W,NUMSUF (./test03.v,83|0): Identifier 'P0' has a numeric value suffix.
    input  wire [63:0] P0,  input wire [63:0] P1,
|
halcheck: *W,STYVAL (./test03.v,83|0): Numeric value '63' used for identifier 'P0'. Use constants to avoid portability issues.
    input  wire [63:0] P0,  input wire [63:0] P1,
|
halcheck: *W,NUMSUF (./test03.v,83|0): Identifier 'P1' has a numeric value suffix.
    input  wire [63:0] P0,  input wire [63:0] P1,
|
halcheck: *W,STYVAL (./test03.v,83|0): Numeric value '63' used for identifier 'P1'. Use constants to avoid portability issues.
    input  wire [63:0] P0,  input wire [63:0] P1,
|
halcheck: *N,DECLIN (./test03.v,83|0): Use a separate line for each HDL declaration.
    input  wire [63:0] P2,  input wire [63:0] P3,
|
halcheck: *W,NUMSUF (./test03.v,84|0): Identifier 'P2' has a numeric value suffix.
    input  wire [63:0] P2,  input wire [63:0] P3,
|
halcheck: *W,STYVAL (./test03.v,84|0): Numeric value '63' used for identifier 'P2'. Use constants to avoid portability issues.
    input  wire [63:0] P2,  input wire [63:0] P3,
|
halcheck: *W,NUMSUF (./test03.v,84|0): Identifier 'P3' has a numeric value suffix.
    input  wire [63:0] P2,  input wire [63:0] P3,
|
halcheck: *W,STYVAL (./test03.v,84|0): Numeric value '63' used for identifier 'P3'. Use constants to avoid portability issues.
    input  wire [63:0] P2,  input wire [63:0] P3,
|
halcheck: *N,DECLIN (./test03.v,84|0): Use a separate line for each HDL declaration.
    input  wire [63:0] P4,  input wire [63:0] P5,
|
halcheck: *W,NUMSUF (./test03.v,85|0): Identifier 'P4' has a numeric value suffix.
    input  wire [63:0] P4,  input wire [63:0] P5,
|
halcheck: *W,STYVAL (./test03.v,85|0): Numeric value '63' used for identifier 'P4'. Use constants to avoid portability issues.
    input  wire [63:0] P4,  input wire [63:0] P5,
|
halcheck: *W,NUMSUF (./test03.v,85|0): Identifier 'P5' has a numeric value suffix.
    input  wire [63:0] P4,  input wire [63:0] P5,
|
halcheck: *W,STYVAL (./test03.v,85|0): Numeric value '63' used for identifier 'P5'. Use constants to avoid portability issues.
    input  wire [63:0] P4,  input wire [63:0] P5,
|
halcheck: *N,DECLIN (./test03.v,85|0): Use a separate line for each HDL declaration.
    input  wire [63:0] P6,  input wire [63:0] P7,
|
halcheck: *W,NUMSUF (./test03.v,86|0): Identifier 'P6' has a numeric value suffix.
    input  wire [63:0] P6,  input wire [63:0] P7,
|
halcheck: *W,STYVAL (./test03.v,86|0): Numeric value '63' used for identifier 'P6'. Use constants to avoid portability issues.
    input  wire [63:0] P6,  input wire [63:0] P7,
|
halcheck: *W,NUMSUF (./test03.v,86|0): Identifier 'P7' has a numeric value suffix.
    input  wire [63:0] P6,  input wire [63:0] P7,
|
halcheck: *W,STYVAL (./test03.v,86|0): Numeric value '63' used for identifier 'P7'. Use constants to avoid portability issues.
    input  wire [63:0] P6,  input wire [63:0] P7,
|
halcheck: *N,DECLIN (./test03.v,86|0): Use a separate line for each HDL declaration.
    input  wire [63:0] P8,  input wire [63:0] P9,
|
halcheck: *W,NUMSUF (./test03.v,87|0): Identifier 'P8' has a numeric value suffix.
    input  wire [63:0] P8,  input wire [63:0] P9,
|
halcheck: *W,STYVAL (./test03.v,87|0): Numeric value '63' used for identifier 'P8'. Use constants to avoid portability issues.
    input  wire [63:0] P8,  input wire [63:0] P9,
|
halcheck: *W,NUMSUF (./test03.v,87|0): Identifier 'P9' has a numeric value suffix.
    input  wire [63:0] P8,  input wire [63:0] P9,
|
halcheck: *W,STYVAL (./test03.v,87|0): Numeric value '63' used for identifier 'P9'. Use constants to avoid portability issues.
    input  wire [63:0] P8,  input wire [63:0] P9,
|
halcheck: *N,DECLIN (./test03.v,87|0): Use a separate line for each HDL declaration.
    input  wire [63:0] P10, input wire [63:0] P11,
|
halcheck: *W,NUMSUF (./test03.v,88|0): Identifier 'P10' has a numeric value suffix.
    input  wire [63:0] P10, input wire [63:0] P11,
|
halcheck: *W,STYVAL (./test03.v,88|0): Numeric value '63' used for identifier 'P10'. Use constants to avoid portability issues.
    input  wire [63:0] P10, input wire [63:0] P11,
|
halcheck: *W,NUMSUF (./test03.v,88|0): Identifier 'P11' has a numeric value suffix.
    input  wire [63:0] P10, input wire [63:0] P11,
|
halcheck: *W,STYVAL (./test03.v,88|0): Numeric value '63' used for identifier 'P11'. Use constants to avoid portability issues.
    input  wire [63:0] P10, input wire [63:0] P11,
|
halcheck: *N,DECLIN (./test03.v,88|0): Use a separate line for each HDL declaration.
    input  wire [63:0] P12, input wire [63:0] P13,
|
halcheck: *W,NUMSUF (./test03.v,89|0): Identifier 'P12' has a numeric value suffix.
    input  wire [63:0] P12, input wire [63:0] P13,
|
halcheck: *W,STYVAL (./test03.v,89|0): Numeric value '63' used for identifier 'P12'. Use constants to avoid portability issues.
    input  wire [63:0] P12, input wire [63:0] P13,
|
halcheck: *W,NUMSUF (./test03.v,89|0): Identifier 'P13' has a numeric value suffix.
    input  wire [63:0] P12, input wire [63:0] P13,
|
halcheck: *W,STYVAL (./test03.v,89|0): Numeric value '63' used for identifier 'P13'. Use constants to avoid portability issues.
    input  wire [63:0] P12, input wire [63:0] P13,
|
halcheck: *N,DECLIN (./test03.v,89|0): Use a separate line for each HDL declaration.
    input  wire [63:0] P14, input wire [63:0] P15,
|
halcheck: *W,NUMSUF (./test03.v,90|0): Identifier 'P14' has a numeric value suffix.
    input  wire [63:0] P14, input wire [63:0] P15,
|
halcheck: *W,STYVAL (./test03.v,90|0): Numeric value '63' used for identifier 'P14'. Use constants to avoid portability issues.
    input  wire [63:0] P14, input wire [63:0] P15,
|
halcheck: *W,NUMSUF (./test03.v,90|0): Identifier 'P15' has a numeric value suffix.
    input  wire [63:0] P14, input wire [63:0] P15,
|
halcheck: *W,STYVAL (./test03.v,90|0): Numeric value '63' used for identifier 'P15'. Use constants to avoid portability issues.
    input  wire [63:0] P14, input wire [63:0] P15,
|
halcheck: *N,DECLIN (./test03.v,90|0): Use a separate line for each HDL declaration.
    input  wire [63:0] P16,
|
halcheck: *W,NUMSUF (./test03.v,91|0): Identifier 'P16' has a numeric value suffix.
    input  wire [63:0] P16,
|
halcheck: *W,STYVAL (./test03.v,91|0): Numeric value '63' used for identifier 'P16'. Use constants to avoid portability issues.
    output wire [63:0] s_u_m,     // final sum row
|
halcheck: *W,STYVAL (./test03.v,92|0): Numeric value '63' used for identifier 's_u_m'. Use constants to avoid portability issues.
    output wire [63:0] c_arr_y//, c0, c1, c2, c3, c4, c5, s0, s1, s2, s3, s4, s5    // final carry row (interpret as <<1)
|
halcheck: *W,STYVAL (./test03.v,93|0): Numeric value '63' used for identifier 'c_arr_y'. Use constants to avoid portability issues.
    input  wire [63:0] P0,  input wire [63:0] P1,
|
halcheck: *W,LCVARN (./test03.v,83|0): Net name 'P0' uses uppercase characters.
    input  wire [63:0] P0,  input wire [63:0] P1,
|
halcheck: *W,LCVARN (./test03.v,83|0): Net name 'P1' uses uppercase characters.
    input  wire [63:0] P2,  input wire [63:0] P3,
|
halcheck: *W,LCVARN (./test03.v,84|0): Net name 'P2' uses uppercase characters.
    input  wire [63:0] P2,  input wire [63:0] P3,
|
halcheck: *W,LCVARN (./test03.v,84|0): Net name 'P3' uses uppercase characters.
    input  wire [63:0] P4,  input wire [63:0] P5,
|
halcheck: *W,LCVARN (./test03.v,85|0): Net name 'P4' uses uppercase characters.
    input  wire [63:0] P4,  input wire [63:0] P5,
|
halcheck: *W,LCVARN (./test03.v,85|0): Net name 'P5' uses uppercase characters.
    input  wire [63:0] P6,  input wire [63:0] P7,
|
halcheck: *W,LCVARN (./test03.v,86|0): Net name 'P6' uses uppercase characters.
    input  wire [63:0] P6,  input wire [63:0] P7,
|
halcheck: *W,LCVARN (./test03.v,86|0): Net name 'P7' uses uppercase characters.
    input  wire [63:0] P8,  input wire [63:0] P9,
|
halcheck: *W,LCVARN (./test03.v,87|0): Net name 'P8' uses uppercase characters.
    input  wire [63:0] P8,  input wire [63:0] P9,
|
halcheck: *W,LCVARN (./test03.v,87|0): Net name 'P9' uses uppercase characters.
    input  wire [63:0] P10, input wire [63:0] P11,
|
halcheck: *W,LCVARN (./test03.v,88|0): Net name 'P10' uses uppercase characters.
    input  wire [63:0] P10, input wire [63:0] P11,
|
halcheck: *W,LCVARN (./test03.v,88|0): Net name 'P11' uses uppercase characters.
    input  wire [63:0] P12, input wire [63:0] P13,
|
halcheck: *W,LCVARN (./test03.v,89|0): Net name 'P12' uses uppercase characters.
    input  wire [63:0] P12, input wire [63:0] P13,
|
halcheck: *W,LCVARN (./test03.v,89|0): Net name 'P13' uses uppercase characters.
    input  wire [63:0] P14, input wire [63:0] P15,
|
halcheck: *W,LCVARN (./test03.v,90|0): Net name 'P14' uses uppercase characters.
    input  wire [63:0] P14, input wire [63:0] P15,
|
halcheck: *W,LCVARN (./test03.v,90|0): Net name 'P15' uses uppercase characters.
    input  wire [63:0] P16,
|
halcheck: *W,LCVARN (./test03.v,91|0): Net name 'P16' uses uppercase characters.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 'c0' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 'c00' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 'c1' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 'c2' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 'c3' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 'c4' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 'c5' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 'c6' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 's0' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 's00' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 's1' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 's2' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 's3' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 's4' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 's5' has a numeric value suffix.
    wire [63:0] c0, c00, c1, c2, c3, c4, c5, c6, s0, s00, s1, s2, s3, s4, s5, s6;
|
halcheck: *W,NUMSUF (./test03.v,95|0): Identifier 's6' has a numeric value suffix.
    wire [63:0] cl0, cl00;
|
halcheck: *W,NUMSUF (./test03.v,97|0): Identifier 'cl0' has a numeric value suffix.
    wire [63:0] cl0, cl00;
|
halcheck: *W,NUMSUF (./test03.v,97|0): Identifier 'cl00' has a numeric value suffix.
    wire [63:0] cl1;
|
halcheck: *W,NUMSUF (./test03.v,98|0): Identifier 'cl1' has a numeric value suffix.
    wire [63:0] cl1;
|
halcheck: *W,STYVAL (./test03.v,98|0): Numeric value '63' used for identifier 'cl1'. Use constants to avoid portability issues.
    wire [63:0] cl2;
|
halcheck: *W,NUMSUF (./test03.v,99|0): Identifier 'cl2' has a numeric value suffix.
    wire [63:0] cl2;
|
halcheck: *W,STYVAL (./test03.v,99|0): Numeric value '63' used for identifier 'cl2'. Use constants to avoid portability issues.
    wire [63:0] cl3;
|
halcheck: *W,NUMSUF (./test03.v,100|0): Identifier 'cl3' has a numeric value suffix.
    wire [63:0] cl3;
|
halcheck: *W,STYVAL (./test03.v,100|0): Numeric value '63' used for identifier 'cl3'. Use constants to avoid portability issues.
    wire [63:0] cl4;
|
halcheck: *W,NUMSUF (./test03.v,131|0): Identifier 'cl4' has a numeric value suffix.
    wire [63:0] cl4;
|
halcheck: *W,STYVAL (./test03.v,131|0): Numeric value '63' used for identifier 'cl4'. Use constants to avoid portability issues.
    wire [63:0] cl5;
|
halcheck: *W,NUMSUF (./test03.v,132|0): Identifier 'cl5' has a numeric value suffix.
    wire [63:0] cl5;
|
halcheck: *W,STYVAL (./test03.v,132|0): Numeric value '63' used for identifier 'cl5'. Use constants to avoid portability issues.
    wire [63:0] cl6;
|
halcheck: *W,NUMSUF (./test03.v,153|0): Identifier 'cl6' has a numeric value suffix.
    wire [63:0] cl6;
|
halcheck: *W,STYVAL (./test03.v,153|0): Numeric value '63' used for identifier 'cl6'. Use constants to avoid portability issues.
    assign cl00 = (c00 << 1);
|
halcheck: *W,SHFTOF (./test03.v,123|0): Shift overflow in module/design-unit tree, some bits will be lost.
    assign cl0 = (c0 << 1);
|
halcheck: *W,SHFTOF (./test03.v,133|0): Shift overflow in module/design-unit tree, some bits will be lost.
    assign cl1 = (c1 << 1);
|
halcheck: *W,SHFTOF (./test03.v,134|0): Shift overflow in module/design-unit tree, some bits will be lost.
    assign cl2 = (c2 << 1);
|
halcheck: *W,SHFTOF (./test03.v,144|0): Shift overflow in module/design-unit tree, some bits will be lost.
    assign cl3 = (c3 << 1);
|
halcheck: *W,SHFTOF (./test03.v,145|0): Shift overflow in module/design-unit tree, some bits will be lost.
    assign cl4 = (c4 << 1);
|
halcheck: *W,SHFTOF (./test03.v,155|0): Shift overflow in module/design-unit tree, some bits will be lost.
    assign cl5 = (c5 << 1);
|
halcheck: *W,SHFTOF (./test03.v,156|0): Shift overflow in module/design-unit tree, some bits will be lost.
    compressor42_vec S1_0 (
|
halcheck: *W,LCVARN (./test03.v,102|0): Module instance name 'S1_0' uses uppercase characters.
module compressor42_vec (
|
halcheck: *W,DIFFMN (./test03.v,3|0): Module name 'compressor42_vec' differs from file name 'test03.v'.
module compressor42_vec (
|
halcheck: *W,MULTMF (./test03.v,3|0): More than one design-unit definition in file 'test03.v'.
module compressor42_vec (
|
halcheck: *N,PRTCNT (./test03.v,3|0): Module/Entity 'compressor42_vec' contains '7' ports.
halcheck: (./test03.v,3): Number of Input ports: 5.
halcheck: (./test03.v,3): Number of Output ports: 2.
    input  wire [63:0] a,
|
halcheck: *W,STYVAL (./test03.v,4|0): Numeric value '63' used for identifier 'a'. Use constants to avoid portability issues.
    input  wire [63:0] b,
|
halcheck: *W,STYVAL (./test03.v,5|0): Numeric value '63' used for identifier 'b'. Use constants to avoid portability issues.
    input  wire [63:0] c,
|
halcheck: *W,STYVAL (./test03.v,6|0): Numeric value '63' used for identifier 'c'. Use constants to avoid portability issues.
    input  wire [63:0] d,
|
halcheck: *W,STYVAL (./test03.v,7|0): Numeric value '63' used for identifier 'd'. Use constants to avoid portability issues.
    output wire [63:0] sum,         // same weight
|
halcheck: *W,STYVAL (./test03.v,9|0): Numeric value '63' used for identifier 'sum'. Use constants to avoid portability issues.
    output wire [63:0] carry        // carry row (to be interpreted as <<1)
|
halcheck: *W,STYVAL (./test03.v,10|0): Numeric value '63' used for identifier 'carry'. Use constants to avoid portability issues.
    wire [63:0] c1;
|
halcheck: *W,NUMSUF (./test03.v,13|0): Identifier 'c1' has a numeric value suffix.
    wire [63:0] c1;
|
halcheck: *W,STYVAL (./test03.v,13|0): Numeric value '63' used for identifier 'c1'. Use constants to avoid portability issues.
    wire [63:0] c2;
|
halcheck: *W,NUMSUF (./test03.v,14|0): Identifier 'c2' has a numeric value suffix.
    wire [63:0] c2;
|
halcheck: *W,STYVAL (./test03.v,14|0): Numeric value '63' used for identifier 'c2'. Use constants to avoid portability issues.
    wire [63:0] s1;
|
halcheck: *W,NUMSUF (./test03.v,15|0): Identifier 's1' has a numeric value suffix.
    wire [63:0] s1;
|
halcheck: *W,STYVAL (./test03.v,15|0): Numeric value '63' used for identifier 's1'. Use constants to avoid portability issues.
    wire [63:0] cout;
|
halcheck: *W,STYVAL (./test03.v,18|0): Numeric value '63' used for identifier 'cout'. Use constants to avoid portability issues.
        for (i = 0; i < 64; i = i + 1) begin
|
halcheck: *W,UNMGEN (./test03.v,22|0): Unnamed generate block found in module 'compressor42_vec'.
	if (i == 0) begin
|
halcheck: *W,UNMGEN (./test03.v,25|0): Unnamed generate block found in module 'compressor42_vec'.
    	else begin
|
halcheck: *W,UNMGEN (./test03.v,28|0): Unnamed generate block found in module 'compressor42_vec'.
    wire [63:0] c1;
|
halcheck: *W,URAWIR (./test03.v,13|0): Wire 'c1' defined in module 'compressor42_vec' is unused (neither read nor assigned).
    wire [63:0] c2;
|
halcheck: *W,URAWIR (./test03.v,14|0): Wire 'c2' defined in module 'compressor42_vec' is unused (neither read nor assigned).
    wire [63:0] cout;
|
halcheck: *W,URDWIR (./test03.v,18|0): Wire 'cout[63]' defined in module 'compressor42_vec' does not drive any object, but is assigned at least once.
    compressor42_vec S1_1 (
|
halcheck: *W,LCVARN (./test03.v,107|0): Module instance name 'S1_1' uses uppercase characters.
    compressor42_vec S1_2 (
|
halcheck: *W,LCVARN (./test03.v,112|0): Module instance name 'S1_2' uses uppercase characters.
    compressor42_vec S1_3 (
|
halcheck: *W,LCVARN (./test03.v,117|0): Module instance name 'S1_3' uses uppercase characters.
    compressor32_vec S1_FINAL (
|
halcheck: *W,LCVARN (./test03.v,124|0): Module instance name 'S1_FINAL' uses uppercase characters.
module compressor32_vec (
|
halcheck: *W,DIFFMN (./test03.v,50|0): Module name 'compressor32_vec' differs from file name 'test03.v'.
module compressor32_vec (
|
halcheck: *W,MULTMF (./test03.v,50|0): More than one design-unit definition in file 'test03.v'.
module compressor32_vec (
|
halcheck: *N,PRTCNT (./test03.v,50|0): Module/Entity 'compressor32_vec' contains '5' ports.
halcheck: (./test03.v,50): Number of Input ports: 3.
halcheck: (./test03.v,50): Number of Output ports: 2.
    input  wire [63:0] a,
|
halcheck: *W,STYVAL (./test03.v,51|0): Numeric value '63' used for identifier 'a'. Use constants to avoid portability issues.
    input  wire [63:0] b,
|
halcheck: *W,STYVAL (./test03.v,52|0): Numeric value '63' used for identifier 'b'. Use constants to avoid portability issues.
    input  wire [63:0] c,
|
halcheck: *W,STYVAL (./test03.v,53|0): Numeric value '63' used for identifier 'c'. Use constants to avoid portability issues.
    output wire [63:0] sm,         // same weight
|
halcheck: *W,STYVAL (./test03.v,56|0): Numeric value '63' used for identifier 'sm'. Use constants to avoid portability issues.
    output wire [63:0] cry        // carry row (to be interpreted as <<1)
|
halcheck: *W,STYVAL (./test03.v,57|0): Numeric value '63' used for identifier 'cry'. Use constants to avoid portability issues.
        for (i = 0; i < 64; i = i + 1) begin
|
halcheck: *W,UNMGEN (./test03.v,64|0): Unnamed generate block found in module 'compressor32_vec'.
    output wire [63:0] cry        // carry row (to be interpreted as <<1)
|
halcheck: *N,DECLIN (./test03.v,57|0): Use a separate line for each HDL declaration.
    compressor42_vec S2_L (
|
halcheck: *W,LCVARN (./test03.v,137|0): Module instance name 'S2_L' uses uppercase characters.
    compressor42_vec S2_R (
|
halcheck: *W,LCVARN (./test03.v,146|0): Module instance name 'S2_R' uses uppercase characters.
    compressor42_vec S3_FINAL (
|
halcheck: *W,LCVARN (./test03.v,157|0): Module instance name 'S3_FINAL' uses uppercase characters.
    wire [63:0] cl6;
|
halcheck: *W,URAWIR (./test03.v,153|0): Wire 'cl6' defined in module 'pp_tree16x64' is unused (neither read nor assigned).
    cla_64bit cla (
|
halcheck: *N,IDLENG (./topMod.v,52|0): Identifier name 'cla' is not of appropriate length (4 to 16 characters).
`timescale 1ns/1ps
|
halcheck: *N,CDNOTE (./cla.v,1|0): The compiler directive '`timescale' is used in the RTL.
module cla_64bit (
|
halcheck: *W,DIFFMN (./cla.v,4|0): Module name 'cla_64bit' differs from file name 'cla.v'.
module cla_64bit (
|
halcheck: *N,PRTCNT (./cla.v,4|0): Module/Entity 'cla_64bit' contains '5' ports.
halcheck: (./cla.v,4): Number of Input ports: 3.
halcheck: (./cla.v,4): Number of Output ports: 2.
    input  [63:0] A,
|
halcheck: *W,STYVAL (./cla.v,5|0): Numeric value '63' used for identifier 'A'. Use constants to avoid portability issues.
    input  [63:0] B,
|
halcheck: *W,STYVAL (./cla.v,6|0): Numeric value '63' used for identifier 'B'. Use constants to avoid portability issues.
    output [63:0] Sum,
|
halcheck: *W,STYVAL (./cla.v,8|0): Numeric value '63' used for identifier 'Sum'. Use constants to avoid portability issues.
    input  [63:0] A,
|
halcheck: *W,LCVARN (./cla.v,5|0): Net name 'A' uses uppercase characters.
    input  [63:0] B,
|
halcheck: *W,LCVARN (./cla.v,6|0): Net name 'B' uses uppercase characters.
    input         Cin,
|
halcheck: *W,LCVARN (./cla.v,7|0): Net name 'Cin' uses uppercase characters.
    output [63:0] Sum,
|
halcheck: *W,LCVARN (./cla.v,8|0): Net name 'Sum' uses uppercase characters.
    output        Cout
|
halcheck: *W,LCVARN (./cla.v,9|0): Net name 'Cout' uses uppercase characters.
    wire [63:0] G, P;     // Generate & Propagate
|
halcheck: *W,LCVARN (./cla.v,12|0): Net name 'G' uses uppercase characters.
    wire [63:0] G, P;     // Generate & Propagate
|
halcheck: *W,STYVAL (./cla.v,12|0): Numeric value '63' used for identifier 'G'. Use constants to avoid portability issues.
    wire [63:0] G, P;     // Generate & Propagate
|
halcheck: *W,LCVARN (./cla.v,12|0): Net name 'P' uses uppercase characters.
    wire [64:0] C;        // Carry bits
|
halcheck: *W,LCVARN (./cla.v,13|0): Net name 'C' uses uppercase characters.
    wire [64:0] C;        // Carry bits
|
halcheck: *W,STYVAL (./cla.v,13|0): Numeric value '64' used for identifier 'C'. Use constants to avoid portability issues.
    wire        Cout;
|
halcheck: *W,URDWIR (./topMod.v,48|0): Wire 'Cout' defined in module 'booth32x32_top' does not drive any object, but is assigned at least once.
halcheck: Total errors   = 0.
halcheck: Total warnings = 281.

  ==========================================================================
Performing synthesizability checks 

cfe64: 15.20.051-s(15.20.s051): (c) Copyright 1995 - 2018 Cadence Design Systems, Inc.
cfe64 Build : Mon May  7 17:15:12 IST 2018 ldvopt246
halsynth: Loading design snapshot....
halsynth: Traversing design hierarchy....
    reg  [63:0] partial [16:0];
|
halsynth: *W,VLGMEM (./multi_f.v,30|0): Module booth_radix4_multiplier has Verilog memories. For large memories, processing may take some time.
        for (i = 0; i < 17; i = i + 1) begin
|
halsynth: *W,LOOPTM (./multi_f.v,34|0): Operation between a loop variable and a non-constant value is repeated more than 10 times.
halsynth: (./multi_f.v,37): Source HDL information for the error/warning mentioned above.
halsynth: (./multi_f.v,38): Source HDL information for the error/warning mentioned above.
halsynth: (./multi_f.v,39): Source HDL information for the error/warning mentioned above.
halsynth: (./multi_f.v,40): Source HDL information for the error/warning mentioned above.
halsynth: Total errors   = 0.
halsynth: Total warnings = 2.

  ==========================================================================
Performing structural checks 

halstruct(64): 15.20-s051: (c) Copyright 1995-2018 Cadence Design Systems, Inc.
visadev(64): 15.20-s051: (c) Copyright 1995-2018 Cadence Design Systems, Inc.
    assign PROD_MSB = FINAL_PROD[63:32];
|
halstruct: *W,TPOUNR (./topMod.v,64|0): Output 'PROD_MSB' of top-level module is not a register.
    assign PROD_MSB = FINAL_PROD[63:32];
|
halstruct: *E,CBPAHI (./topMod.v,64|0): Combinatorial path crossing multiple units drives 'PROD_MSB'.
halstruct: (./topMod.v,64): in instance 'booth32x32_top', 'FINAL_PROD' drives 'PROD_MSB'.
halstruct: (./topMod.v,52): in instance 'booth32x32_top', output 'Sum[32]' of instance 'cla' drives 'FINAL_PROD'.
halstruct: (./cla.v,26): in instance 'booth32x32_top.cla', combinatorial function of 'P' drives 'Sum[32]'.
halstruct: (./cla.v,19): in instance 'booth32x32_top.cla', combinatorial function of input 'A' drives 'P'.
halstruct: (./topMod.v,52): in instance 'booth32x32_top', 's_um' drives input 'A' of instance 'cla'.
halstruct: (./topMod.v,35): in instance 'booth32x32_top', output 's_u_m' of instance 'tree' drives 's_um'.
halstruct: (./test03.v,163): in instance 'booth32x32_top.tree', 's6' drives 's_u_m'.
halstruct: (./test03.v,157): in instance 'booth32x32_top.tree', output 'sum[0]' of instance 'S3_FINAL' drives 's6'.
halstruct: (./test03.v,37): in instance 'booth32x32_top.tree.S3_FINAL', combinatorial function drives 'sum[0]'.
    assign PROD_LSB = FINAL_PROD[31:0];
|
halstruct: *W,TPOUNR (./topMod.v,63|0): Output 'PROD_LSB' of top-level module is not a register.
    assign PROD_LSB = FINAL_PROD[31:0];
|
halstruct: *E,CBPAHI (./topMod.v,63|0): Combinatorial path crossing multiple units drives 'PROD_LSB'.
halstruct: (./topMod.v,63): in instance 'booth32x32_top', 'FINAL_PROD' drives 'PROD_LSB'.
halstruct: (./topMod.v,52): in instance 'booth32x32_top', output 'Sum[0]' of instance 'cla' drives 'FINAL_PROD'.
halstruct: (./cla.v,26): in instance 'booth32x32_top.cla', combinatorial function of 'P' drives 'Sum[0]'.
halstruct: (./cla.v,19): in instance 'booth32x32_top.cla', combinatorial function of input 'A' drives 'P'.
halstruct: (./topMod.v,52): in instance 'booth32x32_top', 's_um' drives input 'A' of instance 'cla'.
halstruct: (./topMod.v,35): in instance 'booth32x32_top', output 's_u_m' of instance 'tree' drives 's_um'.
halstruct: (./test03.v,163): in instance 'booth32x32_top.tree', 's6' drives 's_u_m'.
halstruct: (./test03.v,157): in instance 'booth32x32_top.tree', output 'sum[0]' of instance 'S3_FINAL' drives 's6'.
halstruct: (./test03.v,37): in instance 'booth32x32_top.tree.S3_FINAL', combinatorial function drives 'sum[0]'.
    cla_64bit cla (
|
halstruct: *W,UNCONO (./topMod.v,52|0): Port 'Cout' (which is being used as an output) of entity/module 'cla_64bit' is being driven inside the design, but not connected (either partially or completely) in its instance 'booth32x32_top.cla'.
    assign PP0  = partial[0];
|
halstruct: *W,SYNPRT (./multi_f.v,47|0): Output port 'PP0' is assigned asynchronously.
    assign PP1  = partial[1];
|
halstruct: *W,SYNPRT (./multi_f.v,48|0): Output port 'PP1' is assigned asynchronously.
    assign PP2  = partial[2];
|
halstruct: *W,SYNPRT (./multi_f.v,49|0): Output port 'PP2' is assigned asynchronously.
    assign PP3  = partial[3];
|
halstruct: *W,SYNPRT (./multi_f.v,50|0): Output port 'PP3' is assigned asynchronously.
    assign PP4  = partial[4];
|
halstruct: *W,SYNPRT (./multi_f.v,51|0): Output port 'PP4' is assigned asynchronously.
    assign PP5  = partial[5];
|
halstruct: *W,SYNPRT (./multi_f.v,52|0): Output port 'PP5' is assigned asynchronously.
    assign PP6  = partial[6];
|
halstruct: *W,SYNPRT (./multi_f.v,53|0): Output port 'PP6' is assigned asynchronously.
    assign PP7  = partial[7];
|
halstruct: *W,SYNPRT (./multi_f.v,54|0): Output port 'PP7' is assigned asynchronously.
    assign PP8  = partial[8];
|
halstruct: *W,SYNPRT (./multi_f.v,55|0): Output port 'PP8' is assigned asynchronously.
    assign PP9  = partial[9];
|
halstruct: *W,SYNPRT (./multi_f.v,56|0): Output port 'PP9' is assigned asynchronously.
    assign PP10 = partial[10];
|
halstruct: *W,SYNPRT (./multi_f.v,57|0): Output port 'PP10' is assigned asynchronously.
    assign PP11 = partial[11];
|
halstruct: *W,SYNPRT (./multi_f.v,58|0): Output port 'PP11' is assigned asynchronously.
    assign PP12 = partial[12];
|
halstruct: *W,SYNPRT (./multi_f.v,59|0): Output port 'PP12' is assigned asynchronously.
    assign PP13 = partial[13];
|
halstruct: *W,SYNPRT (./multi_f.v,60|0): Output port 'PP13' is assigned asynchronously.
    assign PP14 = partial[14];
|
halstruct: *W,SYNPRT (./multi_f.v,61|0): Output port 'PP14' is assigned asynchronously.
    assign PP15 = partial[15];
|
halstruct: *W,SYNPRT (./multi_f.v,62|0): Output port 'PP15' is assigned asynchronously.
    assign PP16 = partial[16];
|
halstruct: *W,SYNPRT (./multi_f.v,63|0): Output port 'PP16' is assigned asynchronously.
	s = 2'b11;
|
halstruct: *N,INFNOT (./multi_f.v,18|0): Ignoring wire 's' with no fanout to module/design-unit outputs or child instances.
    	us = 2'b00;
|
halstruct: *N,INFNOT (./multi_f.v,19|0): Ignoring wire 'us' with no fanout to module/design-unit outputs or child instances.
    	ne_1 = 1'b0;
|
halstruct: *N,INFNOT (./multi_f.v,20|0): Ignoring wire 'ne_1' with no fanout to module/design-unit outputs or child instances.
	assign s_u_m = s6;
|
halstruct: *W,SYNPRT (./test03.v,163|0): Output port 's_u_m' is assigned asynchronously.
	assign c_arr_y = c6;
|
halstruct: *W,SYNPRT (./test03.v,164|0): Output port 'c_arr_y' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[0]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[1]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[2]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[3]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[4]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[5]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[6]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[7]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[8]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[9]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[10]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[11]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[12]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[13]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[14]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[15]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[16]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[17]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[18]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[19]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[20]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[21]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[22]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[23]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[24]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[25]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[26]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[27]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[28]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[29]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[30]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[31]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[32]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[33]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[34]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[35]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[36]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[37]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[38]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[39]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[40]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[41]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[42]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[43]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[44]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[45]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[46]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[47]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[48]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[49]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[50]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[51]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[52]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[53]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[54]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[55]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[56]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[57]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[58]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[59]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[60]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[61]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[62]' is assigned asynchronously.
            assign sum[i] = s1[i] ^ d[i] ^ cin_i;
|
halstruct: *W,SYNPRT (./test03.v,37|0): Output port 'sum[63]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[0]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[1]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[2]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[3]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[4]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[5]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[6]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[7]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[8]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[9]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[10]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[11]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[12]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[13]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[14]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[15]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[16]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[17]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[18]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[19]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[20]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[21]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[22]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[23]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[24]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[25]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[26]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[27]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[28]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[29]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[30]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[31]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[32]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[33]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[34]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[35]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[36]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[37]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[38]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[39]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[40]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[41]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[42]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[43]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[44]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[45]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[46]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[47]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[48]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[49]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[50]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[51]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[52]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[53]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[54]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[55]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[56]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[57]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[58]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[59]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[60]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[61]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[62]' is assigned asynchronously.
            assign carry[i]  = (s1[i] & d[i]) | (s1[i] & cin_i) | (d[i] & cin_i);
|
halstruct: *W,SYNPRT (./test03.v,38|0): Output port 'carry[63]' is assigned asynchronously.
            assign cout[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *N,INFNOT (./test03.v,34|0): Ignoring wire 'cout[63]' with no fanout to module/design-unit outputs or child instances.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[0]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[1]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[2]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[3]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[4]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[5]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[6]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[7]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[8]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[9]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[10]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[11]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[12]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[13]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[14]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[15]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[16]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[17]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[18]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[19]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[20]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[21]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[22]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[23]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[24]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[25]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[26]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[27]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[28]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[29]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[30]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[31]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[32]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[33]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[34]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[35]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[36]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[37]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[38]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[39]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[40]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[41]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[42]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[43]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[44]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[45]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[46]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[47]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[48]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[49]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[50]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[51]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[52]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[53]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[54]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[55]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[56]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[57]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[58]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[59]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[60]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[61]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[62]' is assigned asynchronously.
            assign sm[i]  = a[i] ^ b[i] ^ c[i];
|
halstruct: *W,SYNPRT (./test03.v,66|0): Output port 'sm[63]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[0]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[1]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[2]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[3]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[4]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[5]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[6]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[7]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[8]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[9]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[10]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[11]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[12]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[13]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[14]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[15]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[16]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[17]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[18]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[19]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[20]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[21]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[22]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[23]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[24]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[25]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[26]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[27]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[28]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[29]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[30]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[31]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[32]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[33]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[34]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[35]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[36]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[37]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[38]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[39]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[40]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[41]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[42]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[43]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[44]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[45]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[46]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[47]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[48]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[49]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[50]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[51]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[52]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[53]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[54]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[55]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[56]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[57]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[58]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[59]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[60]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[61]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[62]' is assigned asynchronously.
            assign cry[i]  = (a[i] & b[i]) | (a[i] & c[i]) | (b[i] & c[i]);
|
halstruct: *W,SYNPRT (./test03.v,67|0): Output port 'cry[63]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[0]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[1]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[2]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[3]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[4]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[5]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[6]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[7]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[8]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[9]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[10]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[11]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[12]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[13]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[14]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[15]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[16]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[17]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[18]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[19]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[20]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[21]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[22]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[23]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[24]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[25]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[26]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[27]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[28]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[29]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[30]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[31]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[32]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[33]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[34]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[35]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[36]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[37]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[38]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[39]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[40]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[41]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[42]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[43]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[44]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[45]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[46]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[47]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[48]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[49]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[50]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[51]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[52]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[53]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[54]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[55]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[56]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[57]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[58]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[59]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[60]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[61]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[62]' is assigned asynchronously.
            assign Sum[i] = P[i] ^ C[i];
|
halstruct: *W,SYNPRT (./cla.v,26|0): Output port 'Sum[63]' is assigned asynchronously.
    assign Cout = C[64];
|
halstruct: *W,SYNPRT (./cla.v,30|0): Output port 'Cout' is assigned asynchronously.
module booth32x32_top (
|
halstruct: *W,ATLGLC (./topMod.v,3|0): Glue logic inferred in top-level module/design-unit 'booth32x32_top'.
halstruct: (./topMod.v,50): HDL-statement inferred as glue logic.
halstruct: (./topMod.v,63): HDL-statement inferred as glue logic.
halstruct: (./topMod.v,64): HDL-statement inferred as glue logic.
module booth32x32_top (
|
halstruct: *N,NUMDFF (./topMod.v,3|0): Number of single-bit D flip-flops present in the hierarchy is 0.
halstruct: Design facts generated in 'hal.design_facts'.
halstruct: Total errors   = 2.
halstruct: Total warnings = 344.

  ==========================================================================

Analysis summary :

 Errors   : (2)
  CBPAHI (2)     

 Warnings : (627)
  ATLGLC (1)      BITUNS (2)      CDEFCV (1)      CTLCHR (11)    
  DIFFMN (6)      IPRTEX (8)      LCVARN (76)     LOOPTM (1)     
  MAXLEN (8)      MULTMF (2)      MXUANS (4)      NOBLKN (2)     
  NUMSUF (78)     SGNUSG (2)      SHFTOF (8)      STYVAL (64)    
  SYNPRT (340)    TPOUNR (2)      UNCONO (1)      UNMGEN (4)     
  URAWIR (3)      URDWIR (2)      VLGMEM (1)     

 Notes    : (30)
  CDNOTE (4)      DECLIN (13)     IDLENG (2)      INFNOT (4)     
  NUMDFF (1)      PRTCNT (6)     

Analysis complete.

 ==========================================================================

To analyze results, run following command :
    ncbrowse -64bit -cdslib ./INCA_libs/irun.lnx8664.15.20.nc/cds.lib -hdlvar ./INCA_libs/irun.lnx8664.15.20.nc/hdl.var -sortby severity -sortby category -sortby tag ncverilog.log

TOOL:	ncverilog	15.20-s051: Exiting on Mar 01, 2023 at 02:15:24 IST  (total: 00:00:04)
